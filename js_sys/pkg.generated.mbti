// Generated using `moon info`, DON'T EDIT IT
package "bikallem/rsignal/js_sys"

// Values
fn async_run(async () -> Unit noraise) -> Unit

fn dynamic_import(String) -> Promise[JsValue]

fn fetch(String) -> Promise[Response]

let globalThis : JsValue

fn log_js_value(&TJsValue) -> Unit

fn log_str(String) -> Unit

let null : JsValue

let undefined : JsValue

// Errors

// Types and methods
type ArrayBuffer
fn ArrayBuffer::to_jv(Self) -> JsValue

#external
pub type Float64Array
fn Float64Array::new(ArrayBuffer, Int, Int) -> Self
fn Float64Array::op_get(Self, Int) -> Double
fn Float64Array::to_jv(Self) -> JsValue
impl TTypedArray for Float64Array

type JsObject
fn[T] JsObject::get(Self, String) -> T
fn JsObject::new() -> Self
fn JsObject::set(Self, String, JsValue) -> Unit
fn JsObject::to_jv(Self) -> JsValue

type JsValue
fn JsValue::define_property(Self, String, Self) -> Unit
fn JsValue::is_none(Self) -> Bool
fn JsValue::is_null(Self) -> Bool
fn JsValue::is_undefined(Self) -> Bool
fn[T] JsValue::of_jv(Self) -> T
fn[T] JsValue::to_jv(T) -> Self
fn[T] JsValue::to_option(Self) -> T?
fn[T] JsValue::unwrap(Self) -> T

type Promise[T]
fn[A, B] Promise::map(Self[A], (A) -> B) -> Self[B]
fn[T] Promise::new(((T) -> Unit, (Error) -> Unit) -> Unit) -> Self[T]
fn[A] Promise::resolve(A) -> Self[A]
fn[A, B] Promise::then(Self[A], (A) -> Self[B]) -> Self[B]
async fn[T] Promise::wait(Self[T]) -> T

type Response
fn Response::array_buffer(Self) -> Promise[ArrayBuffer]
fn Response::ok(Self) -> Bool
fn Response::status(Self) -> Int
fn Response::status_text(Self) -> String
fn Response::text(Self) -> Promise[String]

#external
pub type Uint8Array
fn Uint8Array::byte_length(Self) -> Int
fn Uint8Array::new(ArrayBuffer) -> Self
fn Uint8Array::op_get(Self, Int) -> Int
fn Uint8Array::set(Self, Self, Int) -> Unit
fn Uint8Array::subarray(Self, Int, Int) -> Self
fn Uint8Array::to_jv(Self) -> JsValue
impl TTypedArray for Uint8Array

#external
pub type Uint8ClampedArray
fn Uint8ClampedArray::new(Uint8Array) -> Self
fn Uint8ClampedArray::to_jv(Self) -> JsValue

// Type aliases

// Traits
pub(open) trait TJsValue {
  to_jv(Self) -> JsValue
}

pub(open) trait TTypedArray {
  buffer(Self) -> ArrayBuffer
}

